#summary Documentation for the Python connector framework

= Introduction =
The Python connector framework provides a simple, quick way to write connectors for the GSA.

= Writing a connector =
== Prerequisites ==
  * Python 2.4
  * [http://cherrypy.org/ CherryPy 3]
The sample files for this documentation are available in the repository.

== Example ==
Here is a simple connector that fetches the contents of a URL and then pushes it to the GSA as a content feed:

{{{
import connector
import urllib2

class URLConnector(connector.TimedConnector):
  CONNECTOR_TYPE = 'url-connector'
  CONNECTOR_CONFIG = {
      'url': { 'type': 'text', 'label': 'URL to fetch' },
      'delay': { 'type': 'text', 'label': 'Fetch delay' }
  }

  def init(self):
    self.setInterval(int(self.getConfigParam('delay')))

  def run(self):
    url = self.getConfigParam('url')
    req = urllib2.Request(url)
    response = urllib2.urlopen(req)
    content = response.read()
    self.sendContentFeed(url=url, action='add', mimetype='text/html',
                         content=content)
}}}

Here are a few things to note about this connector:
  * The `URLConnector` extends the `TimedConnector` class. This `TimedConnector` is a special type of connector that implements a simple scheduling scheme--when it is started, it will call its `run` method periodically, with a delay interval specified by the `setInterval` method.
  * All connectors must have a unique `CONNECTOR_TYPE` field that identifies the particular type of connector.
  * `The CONNECTOR_CONFIG` dictionary specifies configuration fields for the connector. When the connector's configuration form is brought up in the GSA administration interface, this `CONNECTOR_CONFIG` will be used to construct the form.
  * The `init` method, which is available to all connectors, is called when the connector is created or when its configuration is modified. It's the perfect place to load and process configuration parameters.
  * The `sendContentFeed` method packages content data in an XML block that the GSA will accept. Here, the `URLConnector` sends the content as HTML to be added to the GSA's index.

== Running the connector ==
Now that we have a connector written, it's time to use the connector manager to expose this connector to the GSA.

  * Start the connector manager.
{{{
python connectormanager.py --debug --connectors=url_connector.URLConnector
}}}
  The `--debug` flag causes the script to print debug information as it executes (more specifically, all calls to `log()` from connectors are printed). The `--connectors` flag lists the connector classes to be loaded by the connector manager. Each class must be specified with its Python package name relative to the location of `connectormanager.py`. In the above example, the `URLConnector` class is located in the file `url_connector.py` in the same directory as `connectormanager.py`.

  If desired, the `--use_ssl` flag can be specified to use SSL. The `--port` flag can be used to change the default port, which is 38080.

  It's also important to note that multiple connector types can be loaded. To do so, simply separate their names with commas. For example:
{{{
python connectormanager.py --debug --connectors=url_connector.URLConnector,other_connector.OtherConnector
}}}

  (For the purposes of the rest of this section, suppose that this script is running on the host `myconnector.mydomain.com`).
  * Next, open the GSA administration console. Create a new connector manager and set the host to `http://myconnector.mydomain.com:38080` (note: no '/' at the end).
  * Create a connector instance with the new connector manager, and configure the connector appropriately.
  * Ensure that the URLs that the connector feeds into the GSA match the patterns listed in the admin console in the Crawl URLs page. Otherwise, the GSA will reject the feed provided by the connector.

= The `Connector` abstract class =
The `URLConnector` above extends `TimedConnector` in order to use its scheduling scheme. However, the raw `Connector` class can be used to implement a custom scheduling scheme. It also provides a wealth of other methods essential in writing full-featured connectors.

The following is a description of key aspects of `Connector`.

== Identification ==
All concrete connector implementations must provide a unique `CONNECTOR_TYPE` string field that identifies the particular connector type.

== General ==
  * `init()`: An initialization method that a connector can implement if needed. This is called when the connector is constructed and whenever its configuration or schedule is changed. Loading such configuration or scheduling parameters should be done here.
  * `startConnector()`: Called whenever the connector is created or when its configuration or schedule is changed. For example, the connector manager calls the `startConnector` methods of all its stored connectors whenever it starts up. This method must be implemented for the connector to work.
  * `stopConnector()`: Called when the connector manager shuts down, or right before configuration or scheduling is set. This method must be implemented for the connector to work.
  * `restartConnectorTraversal()`:
Note that the connector manager does not give any regard to what happens between `startConnector` and `stopConnector` calls--in other words, it's completely up to the connector to implement its own scheduling scheme. The `TimedConnector` implements an example scheduling scheme; see `timedconnector.py` for details on how to do this.
  * `getStatus()`: Called when the GSA needs the status of the connector. Should return the status code as a string. The code '0' indicates that the connector is OK.

== Configuration and scheduling ==
The configuration and scheduling parameters for the connector is specified by the user in the GSA administration console. The following methods are provided to easily access these parameters.
  * `getConfigParam(param_name)`: Reads the connector's configuration and returns the value of a parameter contained within. The name of the configuration parameter is identical to the name of its field in the configuration HTML form.
  * `getLoad()`: Returns the load setting (documents to traverse per minute).
  * `getRetryDelay()`: Returns the retry delay in milliseconds. The default value is 300000 milliseconds.
  * `getTimeIntervals()`: Returns the time intervals over which to traverse. The method returns a string, with individual time intervals delimited by colons.

The `Connector` class provides more lower-level methods for retrieving configuration and scheduling parameters, but the above methods should suffice in most situations. See the `Connector` documentation for more details.

=== Configuration forms ===
When a user opens the GSA administration page to configure a connector, it is up to the connector to provide its own configuration page as raw HTML text. The following connector methods are called by the connector manager to provide this HTML:
  * `@classmethod getConfigForm()`: Should return empty configuration form table rows encapsulated inside a `<CmResponse><ConfigureResponse><FormSnippet>` CDATA tag. This method is called before the connector object is ever instantiated.
  * `getPopulatedConfigForm()`: Like `getConfigForm()`, except with configuration fields already filled in. The rows returned should only be encapsulated inside a CDATA tag.

Writing code to generate HTML for configuration forms can be quite a hassle. Thus, `Connector` provides a configuration form generator that can create this HTML based on a configuration form specification. A connector can take advantage of this feature by providing a `CONNECTOR_CONFIG` field:
{{{
class ExampleConnector(connector.Connector):
  CONNECTOR_TYPE = 'example-connector'
  CONNECTOR_CONFIG = {
      'example_field': { 'type': 'text', 'label': 'Example field' }
  }
  # no need to implement getConfigForm() and getPopulatedConfigForm().

  # ... remaining code omitted ...
}}}
In this configuration specification, there is a single field named `example_field`. When the HTML is generated, a text input tag will be emitted, and a label with the text "Example field" will be placed to its left. After the connector is created, the value of this field can be accessed with `getConfigParam('example_field')`.
If a connector implementation does choose to use this configuration form generation feature, then it does not need to implement the `getConfigForm()` and `getPopulatedConfigForm()` methods.

== Data storage ==
`Connector` provides the capability to store data that persists between `stopConnector()` and `startConnector()` calls (for example, this data would persist when the connector manager is completely shut down). This data is stored along with the connector's configuration data within the connector manager configuration. The data can be of any type than can be encoded by Pickle.
  * `getData()`: Returns the stored data.
  * `setData(data)`: Sets the data to be stored upon connector shutdown.
Note that the data is written to disk only when the connector manager saves its configuration file.

== Sending data to the GSA ==
Connectors must send data to the GSA in the XML feed format, which is fully described in the [http://code.google.com/apis/searchappliance/documentation/64/feedsguide.html Feeds Protocol Developer's Guide]. `Connector` provides a convenience method that constructs a feed record XML string:
  * `generateFeedRecord(attrs, metadata, content)`: Constructs a feed record. `attrs` is a dictionary of attributes for the record tag, `metadata` is a dictionary of metadata tags to add if needed (can be None), and `content` is a string of content to be added if needed (can be None). For example, this call:
{{{
generateFeedRecord(attrs={'url': 'http://mysite.com/index.html', 'action': 'add', 'mimetype': 'text/html'},
                   metadata={'exampletag1': 'somedata', 'exampletag2': 'moredata'},
                   content='hello there')
}}}
  will return the following XML string (indentation added for clarity):
{{{
<record url="http://mysite.com/index.html" action="add" mimetype="text/html">
  <metadata>
    <meta name="exampletag1" content="somedata"/>
    <meta name="exampletag2" content="moredata"/></metadata>
  <content encoding="base64binary">aGVsbG8gdGhlcmU=\n</content>
</record>
}}}
  This XML record is then ready to be sent to the GSA via `pushToGSA`:
  * `pushToGSA(data, feed_type)`: Pushes a feed to the GSA. The `data` parameter is the XML feed string generated by `generateFeedRecord`. Note that multiple records from `generateFeedRecord` can be concatenated and then sent to the GSA as a batch.

  The following are more convenience methods that construct XML records and send them to the GSA in single function calls:
  * `sendContentFeed(content, **attrs)`: Constructs a content feed composed of a single record and sends it to the GSA. Example usage: `sendContentFeed(url='http://...', action='add', mimetype='text/html', content='<some html>')`. The `url`, `mimetype`, and `content` arguments are required.
  * `sendMultiContentFeed(records, feed_type='incremental')`: Constructs a content feed composed of multiple records and sends it to the GSA. The `records` argument should be a list of tuples of the form `(content, record attributes)`. Example usage: `sendMultiContentFeed([('<some html>', {'url': url, 'action': 'add', 'mimetype': 'text/html'})])`
  * `sendMetadataAndURLFeed(metadata, **attrs)`: Constructs a metadata-and-url feed composed of a single record and sends it to the GSA. Example usage: `sendMetadataAndURLFeed(url='http://...', action='add', mimetype='text/html', metadata={...})`. Note that the `metadata` can be `None` if no metadata is needed to be added. The `url` and `mimetype` fields, however, are required.
  * `sendMultiMetadataAndURLFeed(records, feed_type='incremental')`: Constructs a metadata-and-url feed composed of multiple records and sends it to the GSA. The `records` argument should be a list of tuples of the form `(metadata, record attributes)`. Example usage: `sendMultiContentFeed([({'metatag1': 'data1'}, {'url': url, 'action': 'add', 'mimetype': 'text/html'})])`

  While the above convenience methods do cover the most popular use cases, they do have their limitations. For example, it is impossible with the above methods to construct a content feed that includes metadata. For these situations, the `generateFeedRecord` and `pushToGSA` methods should be used instead.

== Logging ==
The `Connector` class provides a method, `logger()`, that returns a Python Logger object designated for the purpose of the calling connector class. See the [http://docs.python.org/library/logging.html#loggers documentation] for the Python logging library for details on how to use this Logger object.